---
title: "Module 1.4 - Bootstrap and permutation"
output: html_document
---

```{r Init, echo=FALSE}
rm(list=ls())
library(ggplot2)
library(tidyverse)
# ![Today's class](information_hose.jpg)
```


## Howto structure
* Look at how things look we truly replicate experiments
* use bootstrap instead of pipetting! - get summary statistics distribution 
* a more complex bootstrap example
* a permutation example - p-value under null hypothesis


### Simulate experiments
This section mimics actual experimental data, this is not a statistical procedure. 
Assume this is an experiment with sample size n_obs (i.e. n_obs cells)

```{r simulated data}
n_obs = 30
true_mean_vesicles_per_cell = 2.3; 
vesicles_per_cells = rpois(n_obs,true_mean_vesicles_per_cell)
myexperiment = data.frame(vesicles_per_cells)
avg_v_per_cell = mean(vesicles_per_cells)
```

Plot the data
```{r simulated data2}
ggplot(myexperiment,aes(x=vesicles_per_cells)) + 
  geom_histogram(bins=25) + 
  geom_vline(xintercept = avg_v_per_cell,color="red") + 
  geom_vline(xintercept = true_mean_vesicles_per_cell,color="blue") + 
  ggtitle("Vesicle per cell","Red = estimate, Blue = truth")

```
### Repeat the experiment
Because this is SIMULATED experiment we can use the army of "virtual undergrads", 
i.e. repeat the experiment multiple times where each time we measure n_obs cells. 

```{r}
# number of replcia
replicas = 25
vesicles_per_cells = rpois(n_obs*replicas,true_mean_vesicles_per_cell)

# create a factor to say what experiment this is and bind to a data.frame
experiment_id = gl(replicas,n_obs)
myexperiment_replicas = data.frame(vesicles = vesicles_per_cells,replica = experiment_id)
```

Plot all experiments. 
```{r}
avg_per_replica = by(vesicles_per_cells,experiment_id,mean)
df.avg = data.frame(replica=factor(levels(experiment_id)),avg=as.vector(avg_per_replica))


ggplot(myexperiment_replicas,aes(vesicles_per_cells)) + 
  geom_histogram(bins=25) + facet_wrap(~replica) + 
  geom_vline(data=df.avg, aes(xintercept = avg),color="red") + 
  geom_vline(xintercept = true_mean_vesicles_per_cell,color="blue") 

```

Let's look at the difference between real and estimated for each of the 25 REAL experiments
```{r}
ggplot(df.avg,aes(x=avg)) + 
  geom_histogram(bins=15) + 
  geom_vline(xintercept = true_mean_vesicles_per_cell,color="blue") +
  ggtitle("Distribution of sample mean","Sample mean is a random variable!")

```
### Back to the "real" world (only do experiment once)
In the last example, we could truly repeat the experiment with 25 undergrads, what happens if we can't? 

Bootstrap allows us to create estimated samples by sampling from the sample! 
```{r}
# sample from the sample 
sampleFromTheSample = sample(myexperiment$vesicles_per_cells,n_obs*replicas,replace=TRUE)
df.bootstrap = data.frame(vesicles = sampleFromTheSample,replica=experiment_id)
```

Plot it is the same way! 
```{r warning=FALSE}
# this time I'm using tydiverse instead of standard "by"
avg_per_replica = df.bootstrap %>%
                    group_by(replica) %>%
                    summarise(mean = mean(vesicles))

df.boot.avg = data.frame(replica=factor(levels(experiment_id)),avg=avg_per_replica$mean)
ggplot(df.bootstrap,aes(vesicles_per_cells)) + 
  geom_histogram(bins=25) + 
  facet_wrap(~replica) + 
   geom_vline(data=df.boot.avg, aes(xintercept = avg),color="red") + 
   geom_vline(xintercept = true_mean_vesicles_per_cell,color="blue") 
```
Look at the distribution of our bootstrap estimate of the mean
```{r}
ggplot(df.boot.avg,aes(x=avg)) + 
  geom_histogram(bins=15) + 
  geom_vline(xintercept = true_mean_vesicles_per_cell,color="blue") + 
  ggtitle("Bootstrap distribution of the mean")
```

In practice we don't need to keep all the samples of samples, just the summary statistics we care about
```{r}
# one way of doing this, use a for loop. 
avg_boot_sample = array(NA,1000)
for (i in 1:length(avg_boot_sample)){
  bootsample = sample(vesicles_per_cells,replace=TRUE)
  avg_boot_sample[i]=mean(bootsample)
}
mean(avg_boot_sample)
sd(avg_boot_sample)
quantile(avg_boot_sample,c(0.025,0.975))
ggplot(data.frame(avg_boot_sample),aes(avg_boot_sample)) + geom_histogram() + 
  geom_vline(xintercept = avg_v_per_cell,color="red") + 
  geom_vline(xintercept = mean(avg_boot_sample),color="green") + 
  geom_vline(xintercept = true_mean_vesicles_per_cell,color="blue") + 
  ggtitle("Vesicle per cell","Red = estimate, Blue = truth, Greed = bootstrap")


```


Second bootstrap example
```{r}
library(palmerpenguins)
ggplot(penguins,aes(x=sex,y=flipper_length_mm,color=sex)) + geom_violin()

# clean NAs
sum(is.na(penguins$sex))
penguins_clean = penguins[!is.na(penguins$sex),]

# penguins_clean = penguins %>% filter(!is.na(sex))

ggplot(penguins_clean,aes(x=sex,y=flipper_length_mm,color=sex)) + 
  geom_violin()


```

Are there differences in flipper length? 
```{r}
# to make code more readable, create an indicator variable
is_female = penguins_clean$sex=="female"

avg_female = mean(penguins_clean$flipper_length_mm[is_female])
avg_male = mean(penguins_clean$flipper_length_mm[!is_female])
diff_flipper_length= avg_female - avg_male

print(paste("Flipper lenth difference between male and female is: ",diff_flipper_length))
print("Is is REAL?")
```


To build intuition, let's look at the difference from the within group mean (residual)
```{r}
individual_diff_from_mean = array(NA,nrow(penguins_clean))

individual_diff_from_mean[is_female] = penguins_clean$flipper_length_mm[is_female] - avg_female
individual_diff_from_mean[!is_female] = penguins_clean$flipper_length_mm[!is_female] - avg_male

# add to the data_frame
penguins_clean_diff = cbind(penguins_clean,individual_diff_from_mean)

#plot
ggplot(penguins_clean_diff,aes(x=individual_diff_from_mean)) + geom_histogram()

ggplot(penguins_clean_diff,aes(x=sex,y=individual_diff_from_mean)) + geom_violin()
ggplot(penguins_clean_diff,aes(x=sex,y=individual_diff_from_mean,color=island)) + geom_violin()
```
Ok, so it looks like we need to account for "island" effect, can we do the difference within an island? 
```{r}
avg_by_sex_and_island = penguins_clean %>% 
                            group_by(sex,island) %>% 
                            summarise(avg=mean(flipper_length_mm))

individual_diff_from_mean = array(NA,nrow(penguins_clean))
for (i in seq(nrow(avg_by_sex_and_island))) {
  ix = which(penguins_clean$sex==avg_by_sex_and_island$sex[i] &
             penguins_clean$island==avg_by_sex_and_island$island[i])
  individual_diff_from_mean[ix]=penguins_clean$flipper_length_mm[ix] - avg_by_sex_and_island$avg[i] 
}


```
Redo with new difference 
```{r}
penguins_clean_diff = cbind(penguins_clean,individual_diff_from_mean)

#plot
ggplot(penguins_clean_diff,aes(x=individual_diff_from_mean)) + geom_histogram()

ggplot(penguins_clean_diff,aes(x=sex,y=individual_diff_from_mean)) + geom_violin()
ggplot(penguins_clean_diff,aes(x=sex,y=individual_diff_from_mean,color=island)) + geom_violin()
```
Ok, so we can't ignore the island... let's calculate the difference between male and female within an island
```{r}
avg_by_sex_and_island = penguins_clean %>% 
                            group_by(sex,island) %>% 
                            summarise(avg=mean(flipper_length_mm))

diff_flipper_length= mean(avg_by_sex_and_island$avg[avg_by_sex_and_island$sex=="female"] - 
                     avg_by_sex_and_island$avg[avg_by_sex_and_island$sex=="male"])

print(paste("Flipper lenth difference between male and female accounting for island is: ",diff_flipper_length))
print("Is is REAL?")
```


Put that code in a function, we're going to use it lots of times. 
```{r message=FALSE, warning=FALSE}
sex_diff = function(png) {
  avg_by_sex_and_island = png %>% 
                            group_by(sex,island) %>% 
                            summarise(avg=mean(flipper_length_mm))

  diff_flipper_length= mean(avg_by_sex_and_island$avg[avg_by_sex_and_island$sex=="female"] - 
                     avg_by_sex_and_island$avg[avg_by_sex_and_island$sex=="male"])
  return(diff_flipper_length)
}

iter=1000
boot_diff = array(NA,iter)
for (i in seq(iter)) {
  smpl_ix = sample(nrow(penguins_clean),replace = TRUE)
  # create sample from sample dataframe
  png_boot = penguins_clean[smpl_ix,]
  boot_diff[i]=sex_diff(png_boot)
}
```


```{r}
ggplot(data.frame(flipper_difference = boot_diff),aes(x=flipper_difference)) + 
  geom_histogram()
```


## Let's look at two variables, 

```{r setup data, echo = TRUE}
n_obs = 20; 
neuron.spike.rate = rnorm(n_obs);
eye.blinking = neuron.spike.rate+rnorm(n_obs,0,2)
myexperiment = data.frame(neuron.spike.rate=neuron.spike.rate, eye.blinking=eye.blinking)

head(myexperiment)


```

## Plot the data and calculate slope

```{r pressure, echo=TRUE}
ggplot(myexperiment,aes(x=neuron.spike.rate,y=eye.blinking)) + geom_point() + geom_smooth(method=lm)

myslope <- function(x,y) {
  mdl =lm(y ~ x)
  slp=mdl$coef[[2]]
  return(slp)
}

real_slope = myslope(neuron.spike.rate,eye.blinking)
real_slope

```

## Permute blinking

```{r slope after single permutaiton, echo=TRUE}
# here is where the magic happens
# if they are not correlated, 
# it didn't matter if the are paired or not. 
#So we shuffle one of them.  
perm_indx = sample(n_obs,replace=FALSE)
perm_blink = eye.blinking[perm_indx];

# add to dataframe with an indicator
indicator = as.factor(c(array("perm",n_obs),array("real",n_obs)))
neuron = c(neuron.spike.rate,neuron.spike.rate)
blink = c(perm_blink,eye.blinking)
myexperiment = data.frame(indicator,neuron,blink)

ggplot(myexperiment,aes(x=neuron,y=blink,col=indicator)) + geom_point(aes(color=indicator)) +geom_smooth(method=lm)


```

## Repeat many times to get a distribution of possible slopes assuming no connection
```{r}
perm_slopes = array(NA,dim=1000)
for (i in 1:length(perm_slopes)) {
  perm_blink = eye.blinking[sample(n_obs)];
  perm_slopes[i] = myslope(neuron.spike.rate,perm_blink)
}

ggplot(data.frame(perm_slopes),aes(perm_slopes)) + geom_histogram() + geom_vline(xintercept = real_slope)
p_value = 1-mean(real_slope>perm_slopes)
p_value
```
 

 