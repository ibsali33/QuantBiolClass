---
title: "Module 1.4 - Bootstrap and permutation"
author: "A. Gamble, I. Ali, N. Zaitlen"
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
---

```{r setup, echo=FALSE}
library(ggplot2)
library(tidyverse)
library(tidyr)
library(dplyr)
# ![Today's class](information_hose.jpg)
```

## Overview
This session will cover bootstrapping methods in statistics to simulate resampling
or simluate experiment replicability given a set of assumptions. We will start with 
creating a simulated experimental data set which we will then simulate repeating in
order to create a distribution of summary statistics.

Through the session we will increase the complexity of our bootsrapping example
to show the scope of its uses and then share a permutation example which will
calculate a p-value under a null hypothesis.

## Simulate experiments

This section mimics actual experimental data, this is not a statistical procedure. 
In this case, we will simulate an experiment where a researcher is observing the 
number of vescicles in a cell. We will set the number of observations made (number 
of cells we look at) in our simulated experiment. We will provide a "true" mean for 
the experiment. We will use rpois() to create the data set based on our defined
parameters. We will convert the data set into a data frame and then calculate the
average.

```{r simulatedata}
# number of observations aka how many cells are we going to look at?
n_obs <- 30

# assumed true value
true_mean_vesicles_per_cell <- 2.3 

# simulate the creation of the data set
vesicles_per_cells <- rpois(n_obs,true_mean_vesicles_per_cell)

# convert the data set into a data frame which will be needed for plotting
myexperiment <- data.frame(vesicles_per_cells)

# calculate average vesicles per cell
avg_v_per_cell <- mean(vesicles_per_cells)
```

Once we have set all the parameters. Lets plot the data. Create a histogram
looking at the number of vesicles per cell. In addition include a line on top 
of the histogram to show the average of the simulated data set in red and the
true mean vesicles per cell in blue. 
```{r simulated data2}

# pro tip: use geom_vline() to add a verticle line with a designated x intercept
# add a subtitle your plot title with ggtitle("title", "subtitle")

ggplot(myexperiment,aes(x=vesicles_per_cells)) + 
  geom_histogram(binwidth = 1) + 
  geom_vline(xintercept = avg_v_per_cell,color="red") + 
  geom_vline(xintercept = true_mean_vesicles_per_cell,color="blue") + 
  ggtitle("Vesicle per cell","Red = estimate, Blue = truth")+
  labs(x = "Vesicles per Cell",
       y = "Count")

```
### Creating simulated experiment replicates

Because this is SIMULATED experiment we can repeat it as many times as needed, 
Keep in mind that the assumptions we make in the simulated experiment will
ultimately guide the final outcome of our results. This does not replace repeating
the actual experiment, but can help us better understand the probability that 
our results will reproduce given our parameters. This is really useful for 
modeling results in proof-of-concept simulated experiments.

```{r createreplicates}
# set the number of times we want to repeat the experiment (replicas)
replicas <- 25

# we can multiply our observations by our replicates in order to rapidly simulate
# the collection of the data.
vesicles_per_cells <- rpois(n_obs*replicas, true_mean_vesicles_per_cell)

# create a factor to say what experiment this is and bind to a data.frame
# use gl() to generate factor levels
experiment_id <- gl(replicas, n_obs)
myexperiment_replicas <- data.frame(vesicles = vesicles_per_cells, 
                                    replica = experiment_id)
```

Use facet wrapping to plot all of the simulated experiments.
```{r simulationfacets}
# create a data frame of averages grouped by the 'replica' factor we created above
df.avg <- myexperiment_replicas %>%
  group_by(replica) %>%
  summarize(avg_per_replica = mean(vesicles))

# plot all experiment replicates using replicate number as a the separating facet. 
ggplot(myexperiment_replicas, aes(vesicles_per_cells)) + 
  geom_histogram(binwidth = 1) + 
  facet_wrap(~replica) + 
  geom_vline(data=df.avg, aes(xintercept = avg_per_replica),color="red") + 
  geom_vline(xintercept = true_mean_vesicles_per_cell, color="blue") 

```

Let's look at the difference between real and estimated for each of the 25 experiments
```{r meanestimates}
ggplot(df.avg, aes(avg_per_replica)) + 
  geom_histogram(bins = 10) + 
  geom_vline(xintercept = true_mean_vesicles_per_cell, color="blue") +
  ggtitle("Distribution of sample mean","True Mean is in Blue")

```
### Back to the "real" world (only do experiment once)

In the last example, we simulated repeating the experiment 25 times, what happens if we can't? 
Bootstrapping allows us to create experimental subsamples by sampling from the sample! 
```{r subsampling}
# create a subsample with the sample() command. Using our previously created
# myexperimet data frame, lets create a sample of vesicles per cell that is 
# subsampled using bootstrapping with the same number of obervations and replicas
# that we used before. Since bootstrapping is sampling done with replacement be
# sure to set replace = TRUE
subsample1 <- sample(myexperiment$vesicles_per_cells, n_obs*replicas, replace=TRUE)

# the data frame using the subsampled vesicles data and experiment_id from before.
subsample_boostraps <- data.frame(vesicles = subsample1, replica=experiment_id)
```

Using the same plotting apporach from above lets visualize the 25 subsamples
obtained by boostrapping
```{r plottingsubsamples warning=FALSE}
bootstraps_averages <- subsample_boostraps %>%
                    group_by(replica) %>%
                    summarise(mean_vesicles = mean(vesicles))

ggplot(subsample_boostraps, aes(vesicles)) + 
  geom_histogram(binwidth = 1) + 
  facet_wrap(~replica) + 
   geom_vline(data=bootstraps_averages, aes(xintercept = mean_vesicles),color="red") + 
   geom_vline(xintercept = true_mean_vesicles_per_cell,color="blue") 
```

Look at the distribution of our bootstrap estimate of the mean using the method from earlier.
```{r bootstrapdistribution}
ggplot(bootstraps_averages, aes(x=mean_vesicles)) + 
  geom_histogram(bins=15) + 
  geom_vline(xintercept = true_mean_vesicles_per_cell, color="blue") + 
  ggtitle("Bootstrap distribution of the mean")
```

In practice we don't need to keep or visualize all the samples of samples, we just
need the summary statistics. For this example lets scale up by creating an array
of 1000 sub samples using a for loop and visualizing the results.

```{r scalingup}
# create an empty array which can be filled with the 1000 sub samples
avg_boot_sample <- array(NA,1000)

# create a for loop that collects the subsamples and fills the array
for (i in 1:length(avg_boot_sample)){
  bootsample <- sample(vesicles_per_cells,replace=TRUE)
  avg_boot_sample[i] <- mean(bootsample)
}

# calculate the summary statistics from your array of subsamples.
mean(avg_boot_sample)
sd(avg_boot_sample)
quantile(avg_boot_sample,c(0.025,0.975))

# lets take a look. Notice ggplot can only work with data frames. In this case
# we can convert the avg_boot_sample array into a data frame within the ggplot
# command
ggplot(data.frame(avg_boot_sample) ,aes(avg_boot_sample)) + 
  geom_histogram() + 
  geom_vline(xintercept = avg_v_per_cell, color="red") + 
  geom_vline(xintercept = mean(avg_boot_sample), color="green") + 
  geom_vline(xintercept = true_mean_vesicles_per_cell, color="blue") + 
  ggtitle("Vesicle per cell", "Red = estimate, Blue = truth, Green = bootstrap")


```


Second bootstrap example
```{r example2intro}
library(palmerpenguins)
ggplot(penguins,aes(x=sex,y=flipper_length_mm,color=sex)) + geom_violin()

# clean NAs
sum(is.na(penguins$sex))
penguins_clean <- penguins[!is.na(penguins$sex),]

# penguins_clean = penguins %>% filter(!is.na(sex))

ggplot(penguins_clean, aes(x=sex, y=flipper_length_mm, fill=sex)) + 
  geom_violin()


```

Are there differences in flipper length? 
```{r deltaflipperlength}
# to make code more readable, create an indicator variable
is_female <- penguins_clean$sex=="female"

avg_female <- mean(penguins_clean$flipper_length_mm[is_female])
avg_male <- mean(penguins_clean$flipper_length_mm[!is_female])
diff_flipper_length <- avg_female - avg_male

print(paste("Flipper lenth difference between male and female is: ",diff_flipper_length))
print("Is is REAL?")
```


To build intuition, let's look at the difference from the within group mean (residual)
```{r meandifferences}
individual_diff_from_mean <- array(NA,nrow(penguins_clean))

individual_diff_from_mean[is_female] <- penguins_clean$flipper_length_mm[is_female] - avg_female
individual_diff_from_mean[!is_female] <- penguins_clean$flipper_length_mm[!is_female] - avg_male

# add to the data_frame
penguins_clean_diff <- cbind(penguins_clean,individual_diff_from_mean)

#plot
ggplot(penguins_clean_diff, aes(x=individual_diff_from_mean)) +
 geom_histogram()

ggplot(penguins_clean_diff, aes(x=sex, y=individual_diff_from_mean)) +
 geom_violin()
ggplot(penguins_clean_diff, aes(x=sex, y=individual_diff_from_mean, fill=island)) +
 geom_violin()
```
Ok, so it looks like we need to account for "island" effect, can we do the difference within an island? 
```{r islandeffect}
avg_by_sex_and_island <- penguins_clean %>% 
                            group_by(sex,island) %>% 
                            summarise(avg=mean(flipper_length_mm))

individual_diff_from_mean <- array(NA,nrow(penguins_clean))
for (i in seq(nrow(avg_by_sex_and_island))) {
  ix <- which(penguins_clean$sex == avg_by_sex_and_island$sex[i] &
             penguins_clean$island == avg_by_sex_and_island$island[i])
  individual_diff_from_mean[ix] <- penguins_clean$flipper_length_mm[ix] - avg_by_sex_and_island$avg[i] 
}


```

Redo with new difference 

```{r}
penguins_clean_diff <- cbind(penguins_clean,individual_diff_from_mean)

# plot
ggplot(penguins_clean_diff, aes(x=individual_diff_from_mean)) + 
  geom_histogram()

ggplot(penguins_clean_diff,aes(x=sex,y=individual_diff_from_mean)) + 
  geom_violin()
ggplot(penguins_clean_diff,aes(x=sex,y=individual_diff_from_mean,color=island)) + 
  geom_violin()
```

Ok, so we can't ignore the island... let's calculate the difference between male and female within an island
```{r}
avg_by_sex_and_island <- penguins_clean %>% 
                            group_by(sex,island) %>% 
                            summarise(avg=mean(flipper_length_mm))

diff_flipper_length <- mean(avg_by_sex_and_island$avg[avg_by_sex_and_island$sex=="female"] - 
                     avg_by_sex_and_island$avg[avg_by_sex_and_island$sex=="male"])

print(paste("Flipper lenth difference between male and female accounting for island is: ",diff_flipper_length))
print("Is is REAL?")
```


Put that code in a function, we're going to use it lots of times. 
```{r bootstrapfunctions message=FALSE, warning=FALSE}
sex_diff = function(png) {
  avg_by_sex_and_island <- png %>% 
                            group_by(sex,island) %>% 
                            summarise(avg=mean(flipper_length_mm))

  diff_flipper_length <- mean(avg_by_sex_and_island$avg[avg_by_sex_and_island$sex=="female"] - 
                     avg_by_sex_and_island$avg[avg_by_sex_and_island$sex=="male"])
  return(diff_flipper_length)
}

iter <- 1000
boot_diff <- array(NA, iter)
for (i in seq(iter)) {
  smpl_ix <- sample(nrow(penguins_clean), replace = TRUE)
  # create sample from sample dataframe
  png_boot <- penguins_clean[smpl_ix,]
  boot_diff[i] <- sex_diff(png_boot)
}
```


```{r visualizingboots}
ggplot(data.frame(flipper_difference = boot_diff),aes(x=flipper_difference)) + 
  geom_histogram()
```


## Let's look at two variables, 

```{r setupdata, echo = TRUE}
n_obs <- 20; 
neuron.spike.rate <- rnorm(n_obs);
eye.blinking <- neuron.spike.rate + rnorm(n_obs, 0, 2)
myexperiment <- data.frame(neuron.spike.rate = neuron.spike.rate, 
                           eye.blinking =e ye.blinking)

head(myexperiment)


```

## Plot the data and calculate slope

```{r pressure, echo=TRUE}
ggplot(myexperiment, aes(x = neuron.spike.rate, y = eye.blinking)) + 
  geom_point() + 
  geom_smooth(method=lm)

myslope <- function(x,y) {
  mdl <- lm(y ~ x)
  slp <- mdl$coef[[2]]
  return(slp)
}

real_slope <- myslope(neuron.spike.rate,eye.blinking)
real_slope

```

## Permute blinking

```{r slope after single permutaiton, echo=TRUE}
# here is where the magic happens
# if they are not correlated, 
# it didn't matter if the are paired or not. 
#So we shuffle one of them.  
perm_indx <- sample(n_obs,replace=FALSE)
perm_blink <- eye.blinking[perm_indx];

# add to dataframe with an indicator
indicator <- as.factor(c(array("perm",n_obs),array("real",n_obs)))
neuron <- c(neuron.spike.rate,neuron.spike.rate)
blink <- c(perm_blink,eye.blinking)
myexperiment <- data.frame(indicator,neuron,blink)

ggplot(myexperiment, aes(x=neuron,y=blink,col=indicator)) + 
  geom_point(aes(color=indicator)) +
  geom_smooth(method=lm)


```

## Repeat many times to get a distribution of possible slopes assuming no connection
```{r}
perm_slopes <-  array(NA, dim=1000)
for (i in 1:length(perm_slopes)) {
  perm_blink <- eye.blinking[sample(n_obs)];
  perm_slopes[i] <- myslope(neuron.spike.rate,perm_blink)
}

ggplot(data.frame(perm_slopes),aes(perm_slopes)) + 
  geom_histogram() + 
  geom_vline(xintercept = real_slope)
p_value <- 1-mean(real_slope>perm_slopes)
p_value
```
 

 
