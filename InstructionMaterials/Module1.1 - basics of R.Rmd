---
title: "Module 1.1 - Intro to R"
author: "A. Gamble, I. Ali, N. Zaitlen"
output: html_document
  toc: TRUE

---

## Overview

R is one of the most commonly used and powerful statistical programming languages and is used to analyze and manipulate data for virtually every professional industry. Over the last 10 years, powerful new tools within R have emerged to make data manipulation and visualization an easier and more accessible process. R is an open source software which means that it will remain freely available to those who need to use it, but also may change its capabilities and improve over time. 

How does R work?

R reads your data (e.g., from an excel or text file) and makes an image of it, which is stored in temporary memory. When you edit your data, you are only editing an image of it; the original dataset is unaffected.  You can then create and alter the datasets within R, which can then be written back to a permanent file. This is called 'nondestructive editing'. You can also create objects (like lists, vectors, matrices and arrays) from directly within R, as opposed to reading them in from a file.

R can do almost anything you can think of doing with your data, which greatly expands the amount of creativity you can apply to your analyses. By using scripts (".R" files, such as this one), you can keep a record of everything you've done to manipulate and analyze your data. Those benefit you later, and can be published or shared with colleagues.

#### Basics of R: data types and data structures

R works most efficiently with data in the form of vectors, which you can think of as lists of info that fall under a particular class. When multiple vectors of the same length are joined up together they create a data frame, which might look similar to a table you would see in excel. A data frame can have multiple classes of data, in contrast, a data matrix is also like a data frame, with the exception that matricies use one class of data to only one class of data. Arrays allow you to work with multidiensional data. In an array, you can package individual values (in other words scalars) vectors, data frames and matricies. We will see various examples of these items over the course of the lesson.

R recognizes several classes of data that can be 'packaged' into vectors. The most common data types include characters, numerics, integers, logicals and factors. Characters are strings of alphanumeric charaters that are written with quotation marks around them. Integers and Numerics, are interpreted as different classifications of numbers, Integers represent whole numbers and Numerics also include decimals and numbers in scientific notation. Logicals are TRUE / FALSE designations which are very useful for filtering, creating for- loops, or if/else components in your code. Factors can be useful for creating groups or categories of data. We will see examples of each of these over the course of the lesson. 

To run code in an Rmd document (like this one), you can highlight what code you would like to run and click the "Run" button in the top right cornder of this window pane. You can also use the Ctrl+Return shortcut.

Let's start by creating some simple obejects and printing their values.

```{r My_chunck}

# create an object by writing in the object name and assigning it with a value using either the = or the <- symbols. 

x=5
y <- 1 # for creating objects, this is the preferred way since = symbols are used in other contexts

animal <- "cat"

isDog <- FALSE

# to view a value, you can either output it's value by allowing R to print it
x

# but if you have many outputs, they might not be printed out. 
# To make sure you print something, use print()
print(y)

# you can even combine different types of objects and free text by writing a character string string and pasting the variable alongside it: 

paste(x)
paste("X value is:",x)
```

##### Exercise 1. 
R can function as a calculator. Create a new object z that has the value of 2*y-x and print it out.
```{r exercise1}


```


#### Basics of R: vectors and matrices #1
Vectors are the most fundamental data structure in R. Vectors are used to store a bunch of values in a series. Indexing is a term used to articulate the order/position of values within a data structure.

```{r vectors}

# Write a series of consecutive integers using a : between two numbers.
1:4

# Creating a vector object called legs.
legs <- c(4,4,8,6) # note the c() function allows you to create a series of non-consecutive numbers, or a series of character strings.

legs[1] # this will find the first item in the legs vector

legs[c(2,4)] # this will find the second and fourth item in the legs vector

```

##### Exercise 2. 
Print the value of the third item in legs with indexing.
```{r exercise2}



```

#### Basics of R: vectors and matrices #2
You can also give specific names to positions in a vector (and many other things) using the names() function.
```{r vectornames}
specie <- c("cat","dog","spider","ant")
names(legs) <- specie

#when positions are assigned with names, the names can be searched with the indexing function
legs["spider"] 

```

##### Exercise 3. 
Print the number of legs ants have.
```{r exercise3}



```


#### Basics of R: vectors and matrices #3
Operations between vectors are done in order, or by the corresponding element.
```{r vectormath}

# You can do math with numeric vectors of equal length
eyes <- c(2,2,8,2)
eye_to_leg <- eyes/legs

# Calculate averages with the mean() function - see also median(), sd(), min(), max()
mean(eye_to_leg) 

# Math with vectors of different lenth will give you warnings. Try running the code below.
eyes/c(1,3,4)

```

##### Exercise 4. 
Create a new vector with an attribute of your choice (how scary they are?)
print out the attribute of spider from your vector
```{r exercise4}



```

#### Basics of R: vectors and matrices #4
accessing vector via multiple indexes or logical operations
```{r logicaloperations}
# We can see the value and name of items called by indexing. Notice the names are retained if one
# of the two vectors that were part of a mathematical operaption has assigned names.
eye_to_leg[c(1,2)]

# Lets create a vector of boolean values that describes if the animals are, or ar not, mammals.
is_mammal <- c(TRUE,TRUE,FALSE,FALSE)

# Notice that boolean operators (TRUE/FALSE) are written in all-caps or as single letters (T/F)
# and they do not require quotations around them

# Using the is_mammal designation, we can call out all the values in a vector that are TRUE
eye_to_leg[is_mammal]

# Selectively run operations like mean() by calling only the values that are TRUE for a condition
mean(eye_to_leg[is_mammal])

# Output the indexes of items that are TRUE using which()
which(is_mammal)

# You can also create boolean vectors using logical operations to select for conditions
has_two_eyes <- eyes == 2


```


##### Exercise 5
Create a new boolean vector more_than_four_legs and use it to print the names of species with >4 legs. Do it twice, once using the original vector species and once using the names() function
```{r}
more_than_four_legs <- c(F, F, T, T)

legs[more_than_four_legs]
specie[more_than_four_legs]
```


#### Basics of R: vectors and matrices 
matrices are just vectors forced into rectangular shape
```{r}
m<-matrix(1:9,byrow=TRUE,nrow=3)
rownames(m)=c("t1","t2","t3")
colnames(m)=c("p1","p2","p3")

# print m
print(m)

# access elements of m - what are the following three lines doing? 
m[2]
m[2,]
m[,2]
```

##### Exercise 6
print out the third item of the second row
print all the items that are p3
```{r}
m[2, 3]
m[,3]
```



#### Basics of R: Factors
factors are another "core type" in R that is useful for stats
```{r}
cls <- c("Mammal","Mammal","Arachnid","Insecta")
cls_factor <- factor(cls)
levels(cls_factor)

# function by applies function to groups of elements in vectors (and other data structures) by factor
by(eye_to_leg,cls_factor,mean)


```

##### Exercise 7
Create new factor with two levels "big" and "small" and calculate the maximum number of legs per group
```{r}
size <- c("big", "big", "small", "small")
size_factor <- factor(size)
levels(size_factor)

by(legs, size_factor, max)
```


#### Basics of R: Data frames #1
```{r}
# a built-in R datasets
mtcars

# another dataset from the web
library(palmerpenguins)

# you can look at a few rows 
head(penguins)

# specify the number of rows you want to look at
head(penguins,3)

# or look at the structure of the dataframe
str(penguins)

# you can access elements in a dataframe just like a matrix
penguins[2,4]
penguins[2,]

# or get specific items from one column using it's name
penguins$sex[6:10]

```

##### Exercise 8
Calculate the average penguin weight by island 
```{r}
island_factor <- factor(penguins$island)
by(penguins$body_mass_g, island_factor, mean)
```


#### Basics of R: Data frames #3
how to define your own dataframe
```{r}
animals <- data.frame(eyes=eyes,legs=legs,ratio=eye_to_leg,class=cls_factor)
animals

```

Basics of R: Data frames #4
data can have "wide" and "long" structures, try to use long whenever you can
```{r} 
wide <- read.table(textConnection(
"Gene    Control Drug1   Drug2   Drug3   Drug4
Actin     20,249  21,352  22,532  23,557  24,555
Tubulin   8,097   8,986   10,058  11,123  12,246"), header=TRUE)

wide

library(reshape2)
long <- melt(wide,id.vars="Gene")
long
colnames(long)<-c("Gene","Treat","Effect")
long


# for the most part, R prefers long  (since it can support more than 2D data...)
```

##### Exercise 9
Create a new column for fold-increase compared to control
calculate the max drug effect for each gene (consider making it a factor...)
```{r}

```


#### R basics: lists
a generalization of vector - list can include any element
note the double [[]] syntax
```{r}
my_list <- list("cat",7,1:3)
my_list

my_list[1]

my_list[[1]]

```

##### Exercise 10
Create a list that combines a string, a 3x3 matrix, and two scalars
add names to your items
print the product of the 3rd and 4th elements on your list
```{r}
testlist <- list("assess", m, x, y)
print(testlist[c(3,4)])

```


#### R basics: for loops
A loop is super useful way to repeat actions. But often you don't want to repeat the exact same thing, but rather repeat the same action on each element in a list or array. A for loop does that by running the same block (everything between {}) but each time a single variable changes its value. 

```{r}
for (i in 1:length(my_list)) {
  print(my_list[[i]])
}

for (year in 2010:2015){
  print(paste("The year is", year))
}
```

same loop but with indexing (preferred)
```{r} 
years=2010:2015
for (i in 1:length(years)) {
  print(paste("The year is", years[i]))
}
```

<creating arrays>

##### Exercise 10
Create an array  with 4 rows and 3 columns. 
Fill it up with random numbers (check out rnorm). 

Use a single for loop to print all items - in what order does it print them? 

What does it mean to do a single/double loop?

Use a double loop to print 
```{r}

# to create an array use: 
# array(data, dim = c(row_Size, column_Size, matrices, dimnames))
# dim = (defines the dimensions of the array)

# to use create random numbers use:
# rnorm(n, mean, sd)


for(i in 1:4){
  arraydata <- rnorm(12, mean = 1, sd = 2)
  TestArray <- array(data = rnorm(12, mean = 1, sd = 2), dim = c(4, 3)) 
  print(TestArray)

}


```


#### R basics: Logicals statements and flow control
Using logical statements allows for the conditional execution of commands. There are a variety of logical statements that can be used to set conditions and checkpoints for downstream analytical procedures.
```{r}
# simple logicals (>, <, >=, <=)
istrue = 5 > 3
istrue

# not (use an ! to get everything except something)
nottrue = !istrue
nottrue

# OR (use || to return TRUE if any given statement is TRUE)
istrue = 5 < 3 || 2 < 3
istrue

# AND (use && to return TRUE if and only if both given statements are TRUE)
isfalse = 5 < 3 && 2 < 3
isfalse

# & vs &&
isfalse = 5 < 3 & 2 < 3
isfalse

a=c(1,1)
b=c(2,2)
a>1 && b>1 

```


If/else statements evaluate logical statements to create decision points when writing code. 
```{r}
x=5
y=4
if (x<y) {
  print("X < Y")
} else {
  print("Y >= X")
}
```


##### Exercise 11 
Write a for loop over the numbers 1-10 and print even/odd statements. 
hint: The operator %% returns the remainder in a modular division statement

10 / 3  = 3.33333
10 / 3  = 3 remainder 1 (modular division)
10 %% 3 = 1
11 %% 3 = 2

```{r}

for(i in 1:10){
  j<-i%%2
  if(j==1){
    print("Odd")
  } else {
    print("Even")
  }
}


```

#### Basics of R: Functions
functions are very important, they are just an extension of the language you wrote
they need to have inputs and output (return)
```{r}
# here we will create a function called mymean which caculates the mean of a vector
mymean = function(myvector) {
  avg=mean(myvector)
  return(avg)
}

# if we create a list x of 100 random numbers
x<-rnorm(100)
mymean(x) # should return the same value as mean(x)

# we can create an if/else statement that checks if mymean(x) correctly cauculates the mean of x
if (mean(x) == mymean(x)) {
  print("this makes sense")
} else {
  print("The world is crazy!")  
}

```


##### Exercise 12
Create a function that gets two inputs, checks that they are numeric scalar and returns their product. (look up is.numeric() and length())  
```{r}

```

##### Exercise 13
Update your function to return product, mean, sum of the two inputs. How can you return more than one thing from a function? 
```{r}

```

